/-
  This module declares a signature for the base modal language,
  i.e. mono-sorted and with a single modal operator.

  Our primitive modal operator is the diamond.
  Box is defined as notation shorthand for diamond.

  We completely preclude any hybridization by further defining
  the base modal language as the *fragment* of the many-sorted polyadic one,
  generated by propositional variables, modal applications, and logical connectives.
  That is: no state variables, no quantification, no @-binding!
-/

import Hybrid.BNF
import Hybrid.Language
import Hybrid.Proof

hybrid_def ModalBase :=
  sort WFF ::= "◇"(WFF) [poss]

  -- TODO: Allow declaring propositional variables in the DSL
  -- sort WFF ::= prop p | prop q | prop r
  -- Or maybe:
  -- sort WFF ::= countable prop

def FormulaSort := ModalBase.WFF

@[simp]
def IsBase : Fragment ModalBase
  | _, .prop _   => true
  | _, .appl _ φ => IsBase _ φ
  | _, .or φ ψ   => IsBase _ φ && IsBase _ ψ
  | _, .neg φ    => IsBase _ φ
  | _, _         => false

def Modal := Form.fragment IsBase FormulaSort

@[coe]
def Modal.toForm (φ : Modal) : Form ModalBase FormulaSort := φ.1
instance : Coe Modal (Form ModalBase FormulaSort) where
  coe := Modal.toForm

def pvar := ModalBase.prop FormulaSort
def Modal.prop    (p : pvar) : Modal := ⟨.prop p, rfl⟩
def Modal.diamond (φ  : Modal)  : Modal := ⟨ℋ⟨ModalBase.poss⟩ φ.1, φ.2⟩
def Modal.or      (φ ψ : Modal) : Modal := ⟨φ.1 ⋁ ψ.1, by simp only [IsBase, φ.2, ψ.2, Bool.and_self]⟩
def Modal.and     (φ ψ : Modal) : Modal := ⟨φ.1 ⋀ ψ.1, by simp [IsBase]; exact And.intro φ.2 ψ.2⟩
def Modal.imp     (φ ψ : Modal) : Modal := ⟨φ.1 ⟶ ψ.1, by simp [IsBase]; exact And.intro φ.2 ψ.2⟩
def Modal.iff     (φ ψ : Modal) : Modal := ⟨φ.1 ←→ ψ.1, by simp [IsBase, φ.2, ψ.2]⟩
def Modal.neg     (φ : Modal)   : Modal := ⟨∼φ.1, φ.2⟩

/-
  Now we will define the box operator in two ways, and show they coincide:
  -- as the explicit dual of diamond: ~◇~φ,
  -- implicitly, using the low-level polyadic definition of the dual: ~ℋ⟨op⟩ φ.negAll

  We need the first one for ease of use;
  We need the second one to be able to derive a simple form of the K axiom,
  from its general polyadic form.
-/

def Modal.box     (φ  : Modal)  : Modal := (φ.neg).diamond.neg

section IsBase

variable {φ : Form ModalBase FormulaSort}

lemma negAll : φ.negAll = ∼φ := by
  cases φ <;> aesop

@[simp]
lemma baseNegAll (h : IsBase _ φ) : IsBase _ φ.negAll := by
  simp [negAll, IsBase]
  exact h

@[simp]
lemma baseApplDual (h : IsBase _ φ) : IsBase _ (ℋ⟨ModalBase.poss⟩ᵈ φ) := by
  simp [FormL.applDual, IsBase]
  apply baseNegAll h

lemma modalIsBase {φ : Modal} : IsBase _ φ.toForm := by
  obtain ⟨form, isBase⟩ := φ
  cases form with
  | «prop» _  => exact isBase
  | appl _ φ => simp; exact isBase
  | or φ ψ   => simp; exact isBase
  | neg φ    => simp; exact isBase
  | _        => simp at isBase

end IsBase

/-- Low-Level box operator, expressed generically in polyadic logic -/
def Modal.boxLL  (φ  : Modal)  : Modal := ⟨ℋ⟨ModalBase.poss⟩ᵈ φ.1, baseApplDual φ.2⟩

/-- The two representations of `□` are identical` -/
lemma Modal.boxIsLL {φ : Modal} : φ.box = φ.boxLL := by
  obtain ⟨form, isBase⟩ := φ
  cases form <;> aesop

infixr:60 "⟶" => Modal.imp
infixl:65 "⋀" => Modal.and
infixl:65 "⋁" => Modal.or
prefix:100 "□" => Modal.box
prefix:100 "◇" => Modal.diamond
prefix:170 "~" => Modal.neg
infixr:60 "←→" => Modal.iff
