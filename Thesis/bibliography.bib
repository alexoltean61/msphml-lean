
@inproceedings{leustean_operational_2019,
	location = {Cham},
	title = {Operational Semantics and Program Verification Using Many-Sorted Hybrid Modal Logic},
	doi = {10.1007/978-3-030-29026-9_25},
	abstract = {We propose a general framework to allow: (a) specifying the operational semantics of a programming language; and (b) stating and proving properties about program correctness. Our framework is based on a many-sorted system of hybrid modal logic, for which we prove its completeness results. We believe that our approach to program verification improves over the existing approaches within modal logic as (1) it is based on operational semantics which enables a more natural description of the execution than Hoare-style weakest precondition used by dynamic logic; (2) since it is multi-sorted, it allows for a clearer encoding of semantics, with a smaller representational distance to its intended meaning.},
	pages = {446--476},
	booktitle = {Automated Reasoning with Analytic Tableaux and Related Methods},
	publisher = {Springer International Publishing},
	author = {Leuștean, Ioana and Moangă, Natalia and Șerbănuță, Traian Florin},
	editor = {Cerrito, Serenella and Popescu, Andrei},
	date = {2019},
	file = {Submitted Version:/home/alex/Zotero/storage/GT8BZN79/Leuştean et al. - 2019 - Operational Semantics and Program Verification Using Many-Sorted Hybrid Modal Logic.pdf:application/pdf},
}

@misc{goguen_theorem_2021,
	title = {Theorem Proving and Algebra},
	url = {http://arxiv.org/abs/2101.02690},
	doi = {10.48550/arXiv.2101.02690},
	abstract = {This book can be seen either as a text on theorem proving that uses techniques from general algebra, or else as a text on general algebra illustrated and made concrete by practical exercises in theorem proving. The book considers several different logical systems, including first-order logic, Horn clause logic, equational logic, and first-order logic with equality. Similarly, several different proof paradigms are considered. However, we do emphasize equational logic, and for simplicity we use only the {OBJ}3 software system, though it is used in a rather flexible manner. We do not pursue the lofty goal of mechanizing proofs like those of which mathematicians are justly so proud; instead, we seek to take steps towards providing mechanical assistance for proofs that are useful for computer scientists in developing software and hardware. This more modest goal has the advantage of both being achievable and having practical benefits. The following topics are covered: many-sorted signature, algebra and homomorphism; term algebra and substitution; equation and satisfaction; conditional equations; equational deduction and its completeness; deduction for conditional equations; the theorem of constants; interpretation and equivalence of theories; term rewriting, termination, confluence and normal form; abstract rewrite systems; standard models, abstract data types, initiality, and induction; rewriting and deduction modulo equations; first-order logic, models, and proof planning; second-order algebra; order-sorted algebra and rewriting; modules; unification and completion; and hidden algebra. In parallel with these are a gradual introduction to {OBJ}3, applications to group theory, various abstract data types (such as number systems, lists, and stacks), propositional calculus, hardware verification, the \{{\textbackslash}textbackslashlambda\}-calculus, correctness of functional programs, and other topics.},
	publisher = {{arXiv}},
	author = {Goguen, Joseph A.},
	urldate = {2025-08-25},
	date = {2021-01-16},
	keywords = {Computer Science - Logic in Computer Science, Computer Science - Programming Languages, Computer Science - Symbolic Computation},
	file = {Preprint PDF:/home/alex/Zotero/storage/WBRPP6VS/Goguen - 2021 - Theorem Proving and Algebra.pdf:application/pdf;Snapshot:/home/alex/Zotero/storage/DKGPIJN9/2101.html:text/html},
}

@book{blackburn_modal_2001,
	location = {Cambridge},
	title = {Modal Logic},
	series = {Cambridge Tracts in Theoretical Computer Science},
	abstract = {This is an advanced 2001 textbook on modal logic, a field which caught the attention of computer scientists in the late 1970s. Researchers in areas ranging from economics to computational linguistics have since realised its worth. The book is for novices and for more experienced readers, with two distinct tracks clearly signposted at the start of each chapter. The development is mathematical; prior acquaintance with first-order logic and its semantics is assumed, and familiarity with the basic mathematical notions of set theory is required. The authors focus on the use of modal languages as tools to analyze the properties of relational structures, including their algorithmic and algebraic aspects, and applications to issues in logic and computer science such as completeness, computability and complexity are considered. Three appendices supply basic background information and numerous exercises are provided. Ideal for anyone wanting to learn modern modal logic.},
	publisher = {Cambridge University Press},
	author = {Blackburn, Patrick and Rijke, Maarten de and Venema, Yde},
	urldate = {2025-08-25},
	date = {2001},
	doi = {10.1017/CBO9781107050884},
	file = {Snapshot:/home/alex/Zotero/storage/8P4CYS5W/F7CDB0A265026BF05EAD1091A47FCF5B.html:text/html},
}

@incollection{sannella_universal_2012,
	location = {Berlin, Heidelberg},
	title = {Universal algebra},
	abstract = {The most basic assumption in work on algebraic specification is that programs are modelled as algebras. This point of view abstracts from the concrete details of code and algorithms, and regards the input/output behaviour of functions and the representation of data as of primary importance. Representing programs in terms of sets (of data values) and ordinary mathematical functions over these sets greatly simplifies the task of reasoning about program correctness. The necessary underpinnings are offered by universal algebra, necessarily in a many-sorted variant, building on the classical single-sorted version. This chapter summarizes the basic concepts and results concerning many-sorted algebras that will be required for the rest of this book.},
	pages = {15--39},
	booktitle = {Foundations of Algebraic Specification and Formal Software Development},
	publisher = {Springer},
	author = {Sannella, Donald and Tarlecki, Andrzej},
	editor = {Sannella, Donald and Tarlecki, Andrzej},
	urldate = {2025-08-25},
	date = {2012},
	doi = {10.1007/978-3-642-17336-3_1},
}

@article{leustean_many-sorted_2020,
	title = {A Many-sorted Polyadic Modal Logic},
	volume = {173},
	doi = {10.3233/FI-2020-1921},
	abstract = {We propose a general system that combines the powerful features of modal logic and many-sorted reasoning. Its algebraic semantics leads to a many-sorted generalization of boolean algebras with operators, for which we prove the analogue of the Jónsson-Tarski theorem. Our goal was to deepen the connections between modal logic and program verification, while also testing the expressiveness of our system by defining a small imperative language and its operational semantics.},
	pages = {191--215},
	number = {2},
	journaltitle = {Fundamenta Informaticae},
	author = {Leuștean, Ioana and Moangă, Natalia and Șerbănuță, Traian Florin},
	urldate = {2025-08-25},
	date = {2020-03-31},
	file = {Submitted Version:/home/alex/Zotero/storage/2CC8RZ65/Leuştean et al. - 2020 - A Many-sorted Polyadic Modal Logic.pdf:application/pdf},
}

@software{noauthor_lean_nodate,
	title = {The Lean Language Reference: Lean 4.22.0 (2025-08-14)},
	url = {https://lean-lang.org/doc/reference/latest/releases/v4.22.0/},
	publisher = {Lean {FRO}},
	urldate = {2025-08-26},
	file = {Lean 4.22.0 (2025-08-14):/home/alex/Zotero/storage/7BI6T3QS/v4.22.0.html:text/html},
}

@thesis{moanga_modal_2022,
	title = {Modal logic for program specification},
	institution = {University of Bucharest},
	type = {phdthesis},
	author = {Moangă, Natalia},
	date = {2022},
}

@thesis{oltean_formalization_2023,
	title = {A Formalization of Hybrid Logic in Lean},
	institution = {University of Bucharest},
	type = {{BSc} thesis},
	author = {Oltean, Andrei-Alexandru},
	date = {2023},
}

@software{noauthor_formalized_2025,
	title = {Formalized Formal Logic},
	url = {https://formalizedformallogic.github.io/Foundation/book/},
	urldate = {2025-08-27},
	date = {2025},
	file = {Introduction - Formalized Formal Logic:/home/alex/Zotero/storage/DUZ2E2NL/book.html:text/html},
}

@incollection{avigad_quantifiers_nodate,
	title = {Quantifiers and Equality},
	url = {https://leanprover.github.io/theorem_proving_in_lean4/},
	booktitle = {Theorem Proving in Lean 4},
	author = {Avigad, Jeremy and de Moura, Leonardo and Soonho, Kong and Sebastian, Ulrich},
	urldate = {2025-08-27},
	file = {Theorem Proving in Lean 4:/home/alex/Zotero/storage/YJWGGKK6/theorem_proving_in_lean4.html:text/html},
}

@inproceedings{chen_matching_2021,
	location = {Vancouver, Canada},
	title = {Matching mu-logic},
	series = {{LICS} '19},
	abstract = {Matching logic is a logic for specifying and reasoning about structure by means of patterns and pattern matching. This paper makes two contributions. First, it proposes a sound and complete proof system for matching logic in its full generality. Previously, sound and complete deduction for matching logic was known only for particular theories providing equality and membership. Second, it proposes matching μ-logic, an extension of matching logic with a least fixpoint μ-binder. It is shown that matching μ-logic captures as special instances many important logics in mathematics and computer science, including first-order logic with least fixpoints, modal μ-logic as well as dynamic logic and various temporal logics such as infinite/finite-trace linear temporal logic and computation tree logic, and notably reachability logic, the underlying logic of the K framework for programming language semantics and formal analysis. Matching μ-logic therefore serves as a unifying foundation for specifying and reasoning about fixpoints and induction, programming languages and program specification and verification.},
	pages = {1--13},
	booktitle = {Proceedings of the 34th Annual {ACM}/{IEEE} Symposium on Logic in Computer Science},
	publisher = {{IEEE} Press},
	author = {Chen, Xiaohong and Roşu, Grigore},
	urldate = {2025-08-27},
	date = {2021-06-08},
}

@software{cheval_many-sorted_2024,
	title = {Many-Sorted Matching Logic in Lean},
	url = {https://github.com/hcheval/ManySortedMatchingLogic/tree/master},
	author = {Cheval, Horațiu},
	urldate = {2025-08-28},
	date = {2024},
	file = {hcheval/ManySortedMatchingLogic:/home/alex/Zotero/storage/WTS4A5AJ/master.html:text/html},
}

@inproceedings{han_formal_2020,
	location = {New York, {NY}, {USA}},
	title = {A formal proof of the independence of the continuum hypothesis},
	doi = {10.1145/3372885.3373826},
	series = {{CPP} 2020},
	abstract = {We describe a formal proof of the independence of the continuum hypothesis ({CH}) in the Lean theorem prover. We use Boolean-valued models to give forcing arguments for both directions, using Cohen forcing for the consistency of ¬ {CH} and a σ-closed forcing for the consistency of {CH}.},
	pages = {353--366},
	booktitle = {Proceedings of the 9th {ACM} {SIGPLAN} International Conference on Certified Programs and Proofs},
	publisher = {Association for Computing Machinery},
	author = {Han, Jesse Michael and van Doorn, Floris},
	urldate = {2025-08-29},
	date = {2020-01-22},
	file = {Submitted Version:/home/alex/Zotero/storage/YWAZBDCX/Han and van Doorn - 2020 - A formal proof of the independence of the continuum hypothesis.pdf:application/pdf},
}

@inproceedings{bentzen_henkin-style_2021,
	location = {Cham},
	title = {A Henkin-Style Completeness Proof for the Modal Logic S5},
	doi = {10.1007/978-3-030-89391-0_25},
	abstract = {This paper presents a recent formalization of a Henkin-style completeness proof for the propositional modal logic S5 using the Lean theorem prover. The proof formalized is close to that of Hughes and Cresswell [8], but the system, based on a different choice of axioms, is better described as a Mendelson system augmented with axiom schemes for K, T, S4, and B, and the necessitation rule as a rule of inference. The language has the false and implication as the only primitive logical connectives and necessity as the only primitive modal operator. The full source code is available online and has been typechecked with Lean 3.4.2.},
	pages = {459--467},
	booktitle = {Logic and Argumentation},
	publisher = {Springer International Publishing},
	author = {Bentzen, Bruno},
	editor = {Baroni, Pietro and Benzmüller, Christoph and Wáng, Yὶ N.},
	date = {2021},
	file = {Submitted Version:/home/alex/Zotero/storage/4GDJ8X9P/Bentzen - 2021 - A Henkin-Style Completeness Proof for the Modal Logic S5.pdf:application/pdf},
}

@article{blackburn_hybrid_1998,
	title = {Hybrid completeness},
	volume = {6},
	doi = {10.1093/jigpal/6.4.625},
	abstract = {In this paper we discuss two hybrid languages, ℒ(A) and ℒ(↓), and provide them with complete axiomatizations. Both languages combine features of modal and classical logic. Like modal languages, they contain modal operators and have a Kripke semantics. Unlike modal languages, in these systems it is possible to 'label' states by using A and ↓ to bind special state variables.This paper explores the consequences of hybridization for completeness. As we shall show, the challenge is to blend the modal idea of canonical models with the classical idea of witnessed maximal consistent sets. The languages ℒ(A) and ℒ(↓) provide us with two extreme examples of the issues involved. In the case of ℒ(A), we can combine these ideas relatively straightforwardly with the aid of analogs of the Barcan axioms coupled with a modal theory of labeling. In the case of ℒ(↓), on the other hand, although we can still formulate a theory of labeling, the Barcan analogs are not valid. We show how to overcome this difficulty by using {COV}*, an infinite collection of additional rules of proof which has been used in a number of investigations of extended modal logic (see, for example, Passy and Tinchev [12] and Gargov and Goranko [7]).},
	pages = {625--650},
	number = {4},
	journaltitle = {Logic Journal of the {IGPL}},
	shortjournal = {Log J {IGPL}},
	author = {Blackburn, P and Tzakova, M},
	urldate = {2025-09-01},
	date = {1998-07-01},
	file = {Snapshot:/home/alex/Zotero/storage/7EHSQBKZ/6.4.html:text/html},
}

@book{plotkin_structural_1981,
	title = {A Structural Approach to Operational Semantics},
	publisher = {Aarhus University},
	author = {Plotkin, Gordon D.},
	urldate = {2025-09-02},
	date = {1981},
	file = {Available Version (via Google Scholar):/home/alex/Zotero/storage/7H2LVNC4/Plotkin - 1981 - A structural approach to operational semantics.pdf:application/pdf},
}

@article{tymoczko_four-color_1979,
	title = {The Four-Color Problem and Its Philosophical Significance},
	volume = {76},
	doi = {10.2307/2025976},
	pages = {57--83},
	number = {2},
	journaltitle = {The Journal of Philosophy},
	author = {Tymoczko, Thomas},
	urldate = {2025-09-02},
	date = {1979},
}

@book{appel_every_1989,
	title = {Every Planar Map is Four Colorable},
	abstract = {In this volume, the authors present their 1972 proof of the celebrated Four Color Theorem in a detailed but self-contained exposition accessible to a general mathematical audience. An emended version of the authors' proof of the theorem, the book contains the full text of the supplements and checklists, which originally appeared on microfiche. The thiry-page introduction, intended for nonspecialists, provides some historical background of the theorem and details of the authors' proof. In addition, the authors have added an appendix which treats in much greater detail the argument for situations in which reducible configurations are immersed rather than embedded in triangulations. This result leads to a proof that four coloring can be accomplished in polynomial time.},
	pagetotal = {760},
	publisher = {American Mathematical Soc.},
	author = {Appel, Kenneth I. and Haken, Wolfgang},
	date = {1989},
	keywords = {Mathematics / Combinatorics, Mathematics / Discrete Mathematics, Mathematics / General, Mathematics / Geometry / General, Mathematics / Graphic Methods},
}

@book{winskel_formal_1993,
	location = {Cambridge, {MA}, {USA}},
	title = {The Formal Semantics of Programming Languages: An Introduction},
	series = {Foundations of Computing},
	shorttitle = {The Formal Semantics of Programming Languages},
	pagetotal = {384},
	publisher = {{MIT} Press},
	author = {Winskel, Glynn},
	date = {1993-02-05},
}

@book{nipkow_concrete_2014,
	location = {Cham},
	title = {Concrete Semantics},
	publisher = {Springer International Publishing},
	author = {Nipkow, Tobias and Klein, Gerwin},
	urldate = {2025-09-02},
	date = {2014},
	doi = {10.1007/978-3-319-10542-0},
	keywords = {Abstract interpretation, Automated reasoning, Compilers, Denotational semantics, Functional programming, Hoare logic, Induction, Isabelle, Logic, Logical reasoning, Program analysis, Proof assistant, Semantics, Type systems},
}

@book{pierce_programming_nodate,
	title = {Programming Language Foundations},
	url = {https://softwarefoundations.cis.upenn.edu/plf-current/index.html},
	author = {Pierce, Benjamin and de Amorim, Arthur Azevedo and Casinghino, Chris and Gaboardi, Marco and Greenberg, Michael and Hrițcu, Cătălin and Sjöberg, Vilhelm and Tolmach, Andrew and Yorgey, Brent},
	urldate = {2025-09-02},
	file = {Programming Language Foundations:/home/alex/Zotero/storage/5HFTE5LU/index.html:text/html},
}

@misc{bereczky_mechanizing_2022,
	title = {Mechanizing Matching Logic In Coq},
	url = {http://arxiv.org/abs/2201.05716},
	doi = {10.4204/EPTCS.369.2},
	abstract = {Matching logic is a formalism for specifying, and reasoning about, mathematical structures, using patterns and pattern matching. Growing in popularity, it has been used to define many logical systems such as separation logic with recursive definitions and linear temporal logic. In addition, it serves as the logical foundation of the K semantic framework, which was used to build practical verifiers for a number of real-world languages. Despite being a fundamental formal system accommodating substantial theories, matching logic lacks a general-purpose, machine-checked formalization. Hence, we formalize matching logic using the Coq proof assistant. Specifically, we create a new representation of matching logic that uses a locally nameless encoding, and we formalize the syntax, semantics, and proof system of this representation in the Coq proof assistant. Crucially, we prove the soundness of the formalized proof system and provide a means to carry out interactive matching logic reasoning in Coq. We believe this work provides a previously unexplored avenue for reasoning about matching logic, its models, and the proof system.},
	author = {Bereczky, Péter and Chen, Xiaohong and Horpácsi, Dániel and Peña, Lucas and Tušil, Jan},
	urldate = {2025-09-02},
	date = {2022-09-19},
	eprinttype = {arxiv},
	eprint = {2201.05716 [cs]},
	keywords = {Computer Science - Logic in Computer Science},
	file = {Preprint PDF:/home/alex/Zotero/storage/4SVM5CR8/Bereczky et al. - 2022 - Mechanizing Matching Logic In Coq.pdf:application/pdf;Snapshot:/home/alex/Zotero/storage/UMICX9KZ/2201.html:text/html},
}

@report{cheval_matching_2022,
	title = {Matching Logic in Lean: Techincal Report},
	url = {https://gitlab.com/ilds/aml-lean/MatchingLogic},
	abstract = {{GitLab}.com},
	author = {Cheval, Horațiu and Macovei, Bogdan},
	urldate = {2025-09-02},
	date = {2022-10-04},
	file = {Snapshot:/home/alex/Zotero/storage/AXFE88AR/TechnicalReport.html:text/html},
}

@online{noauthor_risc0risc0-lean4_nodate,
	title = {risc0/risc0-lean4: A model of the {RISC} Zero {zkVM} and ecosystem in the Lean 4 Theorem Prover},
	url = {https://github.com/risc0/risc0-lean4},
	urldate = {2025-09-02},
	file = {risc0/risc0-lean4\: A model of the RISC Zero zkVM and ecosystem in the Lean 4 Theorem Prover:/home/alex/Zotero/storage/RSJ6Y27H/risc0-lean4.html:text/html},
}

@software{noauthor_nethermindethevmyullean_2025,
	title = {{NethermindEth}/{EVMYulLean}},
	url = {https://github.com/NethermindEth/EVMYulLean},
	abstract = {Executable formal model of the {EVM} and Yul in Lean 4.},
	publisher = {Nethermind},
	urldate = {2025-09-02},
	date = {2025-08-21},
}

@software{noauthor_nethermindethsail-riscv-lean_2025,
	title = {{NethermindEth}/sail-riscv-lean},
	url = {https://github.com/NethermindEth/sail-riscv-lean},
	abstract = {Lean formalisation of the Sail {RISC}-V specification},
	publisher = {Nethermind},
	urldate = {2025-09-02},
	date = {2025-08-29},
}

@article{rosu_overview_2010,
	title = {An overview of the K semantic framework},
	volume = {79},
	doi = {10.1016/j.jlap.2010.03.012},
	series = {Membrane computing and programming},
	abstract = {K is an executable semantic framework in which programming languages, calculi, as well as type systems or formal analysis tools can be defined, making use of configurations, computations and rules. Configurations organize the system/program state in units called cells, which are labeled and can be nested. Computations carry “computational meaning” as special nested list structures sequentializing computational tasks, such as fragments of program; in particular, computations extend the original language or calculus syntax. K (rewrite) rules generalize conventional rewrite rules by making explicit which parts of the term they read, write, or do not care about. This distinction makes K a suitable framework for defining truly concurrent languages or calculi, even in the presence of sharing. Since computations can be handled like any other terms in a rewriting environment, that is, they can be matched, moved from one place to another in the original term, modified, or even deleted, K is particularly suitable for defining control-intensive language features such as abrupt termination, exceptions, or call/cc. This paper gives an overview of the K framework: what it is, how it can be used, and where it has been used so far. It also proposes and discusses the K definition of Challenge, a programming language that aims to challenge and expose the limitations of existing semantic frameworks.},
	pages = {397--434},
	number = {6},
	journaltitle = {The Journal of Logic and Algebraic Programming},
	shortjournal = {The Journal of Logic and Algebraic Programming},
	author = {Roșu, Grigore and Șerbănuță, Traian Florin},
	urldate = {2025-09-02},
	date = {2010-08-01},
	file = {ScienceDirect Full Text PDF:/home/alex/Zotero/storage/BKQMKW2S/Roșu and Șerbănută - 2010 - An overview of the K semantic framework.pdf:application/pdf;ScienceDirect Snapshot:/home/alex/Zotero/storage/W3Q3ADTP/S1567832610000160.html:text/html},
}

@misc{leustean_hybrid_2019,
	title = {From Hybrid Modal Logic to Matching Logic and Back},
	url = {http://arxiv.org/abs/1907.05029},
	doi = {10.4204/EPTCS.303.2},
	abstract = {Building on our previous work on hybrid polyadic modal logic we identify modal logic equivalents for Matching Logic, a logic for program specification and verification. This provides a rigorous way to transfer results between the two approaches, which should benefit both systems.},
	author = {Leuştean, Ioana and Moangă, Natalia and Șerbănuță, Traian Florin},
	urldate = {2025-09-02},
	date = {2019-09-02},
	eprinttype = {arxiv},
	eprint = {1907.05029 [cs]},
	keywords = {Computer Science - Logic in Computer Science},
	file = {Preprint PDF:/home/alex/Zotero/storage/5YRBKBZ3/Leuştean et al. - 2019 - From Hybrid Modal Logic to Matching Logic and Back.pdf:application/pdf;Snapshot:/home/alex/Zotero/storage/AFNGNWPI/1907.html:text/html},
}

@online{noauthor_opencomplsail-riscv-lean_nodate,
	title = {opencompl/sail-riscv-lean},
	url = {https://github.com/opencompl/sail-riscv-lean},
	urldate = {2025-09-03},
	file = {opencompl/sail-riscv-lean:/home/alex/Zotero/storage/CUFCD9PI/sail-riscv-lean.html:text/html},
}
